# shlab

实现简易shell，包括bg、fg等作业控制命令以及ctrl-c、ctrl-z等信号的处理

![shell](https://pic3.zhimg.com/80/v2-2cca38d39e27f39367d74d74ad03d07a_720w.webp)

## 功能

- quit，退出shell
- jobs，列出所有后台任务
-  bg \<job\>，job收到SIGCONT信号后，后台执行
-  fg \<job\>，job收到SIGCONT信号后，前台执行
- ctrl-c，给当前的前台进程组发送SIGINT信号
- ctrl-z，给当前的前台进程组发送SIGTSTP信号
- 回收所有僵尸进程
- 如果任何作业因收到未捕获的信号而终止，则shell应该识别此事件并打印信息

### 提示

- 在kill函数的参数中使用-pid而不是pid，因为参数小于-1时，信号将送往以-pid为组标识的进程
- 在eval中父进程必须先阻止SIGCHLD，在添加job之后解除SIGCHLD，由于子进程继承父进程因此子进程执行子程序之前，先解除对SIGCHLD信号的阻塞
- 子进程应该调用setpgid(0,0)，这会将子进程放到一个新的进程组中，其组ID与子进程的PID相同。这样前台进程组只有一个shell程序

## 异常控制流

### 系统调用错误处理
当Unix系统级函数遇到错误时，它们通常会返回-1并设置全局变量errno来表示出错原因

### 僵尸进程
当一个进程由于某种原因终止时，内核并不是立即把它从系统中删除，它仍然消耗系统资源，保持在一种已终止的状态中，这种进程被称作僵死进程。当父进程回收资源时内核将子进程的退出状态传递给父进程，抛弃已终止的子进程后，此进程才不存在了。如果父进程没有回收它的僵死进程就终止了，那么内核会安排init进程（PID=1）去回收它们

### 信号
Linux信号是一种更高层的软件形式的异常，允许进程和内核中断其他进程。它由内核发出，通知进程系统中发生了一个某种类型的事件。信号在内核中的表示如下图所示。pending位向量中维护着待处理信号的集合；blocked位向量中维护着被阻塞地信号集合。
![signal](https://pic3.zhimg.com/80/v2-4584e9755665d71e13e2a678a4a9d322_720w.webp)

#### 发送信号
发送信号的机制都是基于进程组这个概念的，每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识。

#### 接收信号
时机：从内核模式要切换到用户模式时，例如从系统调用返回或是完成了一次上下文切换。  

过程：
- 内核计算进程的为被阻塞的待处理信号的集合pnb=pending & ~blocked
  - 集合为空，将控制传递到逻辑控制流中的下一条指令
  - 集合不为空，内核会选择集合中的某个信号（通常为值最小的信号）​，强制进程接收

#### 堵塞和解除
一个进程可以有选择地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的信号不会被接收，直到进程取消对这种信号的阻塞在任何时刻，一种类型至多只会有一个待处理信号。一个待处理信号最多只能被接收一次。

#### 信号处理函数
信号处理函数应该遵守以下规定：
- 简单
- 调用异步信号安全的函数（**printf不安全**）
- **保存和恢复errno，将errno保存为局部变量，再在返回时重置errno**
- **阻塞所有的信号，保护对共享全局数据结构的访问**
- 用volatile声明全局变量，使得全局变量每次都从内存读，但并没有保证原子性
- 用sig_atomic_t声明那些仅进行读和写操作的变量

## lab

### shell

builtin_cmd：if判断指令并调用对应函数即可
eval：通过parseline，获取参数列表argv并确定指令是否为内建指令
  - 内建指令，执行builtin_cmd
  - 非内建指令，需要阻塞SIGCHLD并创建子进程执行
    - 子进程解除SIGCHLD阻塞，调用setpgid(0,0)，执行对应程序
    - 父进程添加任务并获取JID后恢复原来的堵塞集合
      - 后台执行，输出语句
      - 前台执行，等待前台执行

waitfg：轮询 + sigsuspend完成

### bgfg实现

do_bgfg：检查参数是否正确，涉及到全部变量需要堵塞全部信号
- 前台，修改state，给停止的进程发SIGCONT，恢复堵塞集合，等待前台执行
- 后台，修改state，给停止的进程发SIGCONT，恢复堵塞集合

### 信号处理

涉及到信号处理需要保存和恢复errno

sigint_handler/sigstsp_handler：
- 堵塞全部信号，用fgpid获取pid，恢复全部信号
- kill(-pid,sig)
- 设置状态

sigchld_handler：
- 保存errno、阻塞全部信号
- 调用waitpid
  - 暂停：输出语句
  - 异常终止：输出语句，deletejob
  - 正常终止：deletejob
- 恢复阻塞集合、errno

### 问题

- 被暂停进程的返回state为127而不是20，其他功能正常，暂时不知原因

