# datalab

### bitXor
根据Xor真值表，可以得出```~( (x&y) | (~x&~y) )```
| x   | y   | val |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 0   |

由于题目要求，需要修改|，把~代入得到```( ~(x&y) ) & ( ~(~x&~y) )```


### tmin

补码最小值```0x80000000```即```1<<31```

### negate
因为```x + (-x) = 0```，```x + (~x) = 0xFFFFFFFF```，所以```-x = (~x) + 1```

### allOddBits

构造出0xAAAAAAAA进行判断
```
int mask = 0xAA + (0xAA << 8);
mask = mask | (mask << 16);
```


### isAsciiDigit
首先判断高26位是否为0，再用异或对某些位数进行判断
```
// 110xxx
int case1 = !((x >> 3) ^ 6);
// 11100x
int case2 = !((x >> 1) ^ 28);
```

### logicalNeg
只有0和tmin代入negate函数得到的结果还是它们自己，其他数相差一个负号，由此可以通过符号位进行判断

### floatScale2

1. 按照IEEE754单浮点数标准，将阶码和尾数拆出来
2. 分为三种情况进行讨论
   - NAN和无穷，直接返回
   - 非规格化，将尾数*2并返回
   - 规格化，将阶码+1并返回

### floatFloat2Int

1. 按照IEEE754单浮点数标准，将阶码和尾数拆出来
2. 阶码减去偏置量后得到e，一共分为三种情况
   - e >= 31，返回0x80000000
   - e <= 0，返回0
   - 其他，将尾数补全并进行左移或右移操作，再根据符号位返回

### floatPower2

1. 根据阶码exp分为三种情况
   - exp > 127，返回0x80000000
   - exp < -126，返回0
   - 其他，exp << 23

缺失的部分实验参考自[这篇文章](https://zhuanlan.zhihu.com/p/409951270)