# 存储引擎

- 本节课主要关注面向磁盘（SSD、HDD、网络存储等）的数据库系统

![common](https://pic3.zhimg.com/80/v2-b7fb0e6b66470f742f35eca57345909a_720w.webp)

一般数据库文件是按照特定的格式去编码并作为操作系统中的文件进行存储。这种方式是通过进行OS读写并由存储引擎去管理和维护。

- 存储引擎需要解决两个问题：
  1. 存储：数据如何存储
  2. 调度：数据如何在磁盘和内存之间流动

## 存储

- 数据库文件以页为单位存储，页内包含头部和数据，需要解决：
  - 如何存储和定位页
  - 如何存储和定位页内的数据

- 存储和定位页，一般使用页目录的方式进行管理
- 存储和定位页内的数据，一般有两种方式
  - Tuple-oriented
  - Log-structured

### Tuple-oriented

- 数据部分只存储tuple
- 一般，采用"slotted pages"的方法定位数据，将catalogs单独存放到某些pages
![slotted pages](https://pic2.zhimg.com/80/v2-de63aed5539a2f67f44f02f0e16234d5_720w.webp)

### Log-structured

- 数据部分存储log，根据日志得到数据并周期性地压缩日志
- 主要用于KV数据库，方便写，不方便读

### 表示
一个元组实际上就是一段字节的序列或者说byte的数组，DBMS的任务就是将那些bytes翻译成有意义的属性值
  - 由于浮点数会有精度损失，所以需要改为定点数或字符串存储
  - 保存内容太长无法在单个page中容纳时，可以采取以下方法（一般不要在数据库中存大文件）：
    - 存放到另外的page
    - 存储在外部文件中

### catalogs
DBMS将数据库的元数据存储在内部的catalog中，包括表名、索引、视图、用户权限等信息。

### 工作负载

- OLTP：专注于事务，通常涉及小部分数据写，因而常用于网购商城一类软件
- OLAP：专注于分析，通常涉及大量数据的读，因而常用于企业的数据分析
- HTAP：OLTP和OLAP的混合

### 数据模型
N-ary Storage Model：按行存储，适用于OLTP  
Decomposition Storage Model：按列存储，适用于OLAP

## 调度

- 空间控制
  - 控制写磁盘的位置
  - 实现空间局部性

- 时间控制
  - 何时写磁盘、何时读磁盘，尽可能减少磁盘操作

### 缓存池

缓存池实现：将一部分内存以页为单位划分出来，再使用页表进行缓存池管理

#### 优化

- 多缓存池包括数据库池、数据池、索引池等，减少锁的争夺
- 预取策略，优化顺序扫描和索引扫描
- 扫描共享，利用某个查询从磁盘中读取的数据，并将该数据用于其他查询中
- 绕过缓存池，不用缓存池直接使用内存，常用于仅使用一次数据的查询或者保存中间结果
- 绕过OS，不使用OS的缓存，减少冗余以及IO开销

#### 替换策略

- LRU
- CLOCK

但是某些情况，我们想移除的页是最近被使用的，例如sequential flooding（顺序扫描会导致热数据被替换），改进方法：

- LRU-K：记录最后K次访问以及访问间隔
- 局部策略：对不同的访问采用不同的内存池
- 优先级提示：提供额外信息告诉存储引擎某些页是否重要

### 脏页

脏页的替换需要先写到磁盘中才能加载入新的页，2次的磁盘IO。为了减少开销，可以设置一个线程周期性的将脏页写入磁盘，这样就可以替换脏页或仅仅将脏页置0。但是在脏页写入磁盘前，需要先写日志(WAL)

### 其他缓存
一般涉及到经常写和读的操作都要进行缓存，比如，查询（热点）缓存、日志缓存等

## 数据结构

数据库中主要使用的数据结构是哈希表和树

### 哈希表

- 哈希函数选择
  - CRC、MurmurHash、std::hash、CityHash、FarmHash、XXHash

- 哈希冲突解决
  - 静态哈希（略）
  - 动态哈希
    - 拉链法
    - Extendible Hashing
    - Linear Hashing

tips：哈希表不要用于索引

## 索引

表索引：包含表的一部分属性的副本，按照特定的排序和组织起来以支持快速的检索和更新。逻辑上，表和索引是同步的，所以需要考虑存储和维护的开销

### B+树

B+树适合于顺序搜索、区间搜索、随机搜索、右模糊搜索因而经常用于表或索引的存储。

tip：当前的数据库对左模糊也有优化

#### 索引
聚簇索引（主键索引）的叶子节点包含了完整的记录行
非聚簇索引（普通索引）的叶子节点只有字段和主键ID，需要回表查询（对于顺序遍历，可以记录需要访问的页一次性读到内存中）

#### 设计

- node size
  - 设备速度越慢，node size应该越大（尽可能多读数据）
  - 分析性数据库，node size应该大一些，事务性数据库node size小一些

- 合并阈值
  - 减小合并阈值或延迟合并操作减少频繁的合并和分裂

- 可变长的key
  - 存储其指针
  - 固定长度不足填充
  - slot数组

- 内部节点搜索
  - 线性
  - 二分
  - 偏移

#### 优化
- 前缀压缩、冗余key压缩

### 索引并发
![lock vs latch](https://ask.qcloudimg.com/http-save/6869393/01e2iffwxd.jpeg?imageView2/2/w/1620)

#### latch

1. OS提供的阻塞锁
  - 例子：std::mutex -> pthread_mutex_t -> [futex](https://cloud.tencent.com/developer/article/1176832)
  - 竞争的线程会陷入睡眠，因此不会出现大量的竞争或者消耗系统的资源，但是线程的睡眠和唤醒本身需要OS支持，因此开销较大，所以不适合大规模使用
2. 自旋锁
   - 例子：std::atomic
   - 单个指令实现加锁解锁，因此很高效，但是会陷入死循环，增大了系统开销

3. 读写锁
   - 允许多个读者进入，需要管理读者和写者

#### 哈希表并发

- 访问方向一致，不会死锁
- 扩容时，加全局锁，给桶或槽加局部锁

#### B树并发

- 每个结点加锁，先锁根节点，从根节点出发，锁孩子节点，解锁父节点
- 对于写操作，需要判断孩子节点是不是安全节点（不会受到分裂或合并的影响），如果是安全节点再释放父节点
- 每次操作都需要对根节点加锁，根节点成为瓶颈，由此可以采用"乐观"的想法，给父节点加读锁，如果父节点会被影响就从头开始加写锁（类似回滚）
- 一个方向遍历避免死锁



