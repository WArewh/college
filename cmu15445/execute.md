# 执行引擎

## 排序
当数据量过大不能存到内存中时，一般采用外部归并排序。外部归并排序优化手段如下：
- 预取，减少了I/O请求的等待时间
- 只取行ID和相关字段，减少合并趟数

如果字段有聚簇B+树索引，那么就可以直接使用。

## 聚集

实现聚集可以采用排序或者哈希

```GROUP BY```和```DISTINCT```不需要排序，那么采用哈希更好。由于内存可能不足，所以需要外部哈希。外部哈希将聚集的字段作为key做形成一个哈希表，碰撞的key放到一个桶中，随后每个桶再hash

如果聚集起来是为了计算，可以在二次哈希时，记录中间结果完成

## 连表(内连接)
三种优化join的方法
- 嵌套循环join优化
  - 占用页数少的表放在前面
  - 分块
  - 占用页数多的表采用索引
- 排序合并join
  - 如果两个表重复字段多会退化为嵌套循环
  - 结果需要排序或者其中有表已经排过序join效率很高
- 哈希join
  - 基础哈希join：扫描外表做hash，内表去查
  - 优化
    - 布隆过滤器
    - Grace哈希join
      - 两个表都hash存在硬盘中
      - 每个桶中的数据做join
      - 如果桶很大，存不到内存中就再次hash

结论：如果有数据倾斜（重复值多或冲突多）或者结果需要排序，那么排序合并好于哈希。其他情况选择hash

## 查询执行
SQL执行：把关系代数中每一种操作抽象为一个Operator，将整个SQL构建成一个Operator树

- 处理模型
  - 火山模型：从根节点到叶子结点自上而下地递归调用next()函数，每次处理一个tuple
      - 简单，每个 Operator 可以单独实现逻辑
      - Joins Subqueries Order By 等操作经常会阻塞
      - 调用next接口次数太多
  - 物化模型：每个operator一次处理所有的输入，处理完之后将所有结果一次性输出
      - 适合OLTP负载，这些查询每次只访问小规模的数据，只需要少量的函数调用
      - 不适合OLAP负载
  - 向量化/批处理模型：火山和物化模型的折衷，next()接口会返回一批的元组
      - 比较适合OLAP查询

- 访问方法
  - 顺序扫描
    - 优化方法：
      - 预取、算子并行、绕过缓冲池、晚物化、聚簇索引
      - Zone map：给每个页预先计算某些值，比如最值、均值等
  - 索引扫描
    - 单索引
    - 多索引（bitmap scan）
  - 删除修改
    - 算子必须记录这次执行涉及那些数据，否则会有问题，因为修改删除会更改索引位置
  - 表达式求值
    - 拆成算子，形成一棵树计算。但是效率会低，可以将一些结果直接算出来

- 并发
  - 进程、进程池、线程
  - 查询间、查询内
  - 操作符内并行
    - 水平切分：将数据拆解成多个子集，然后并行地执行相应的操作符，最后合并或划分
    - 垂直切分：按每个阶段划分，类似流水线
    - Bushy：水平和垂直的折衷
  - IO并行
    - 多磁盘（对数据库透明）：RAID
    - 分库分表
      - 垂直切分：类似按列存储
      - 水平切分

## 查询优化

- 启发式：利用特定的规则对查询进行优化，移走查询中低效率的部分，需要元数据
- 基于代价：估计多个执行计划的代价，选择最低代价方案，需要数据

![arch](https://zhang-each.github.io/2021/12/01/cmudbs4/image-20211130192239501.png)

1. SQL Rewriter：在该步骤当中，可以通过某些转换规则让我们以某种方式对SQL进行重写

2. SQL Parser：将SQL字符串解析成SQL语法树

3. Binder：将查询对象绑定到数据库实体

4. Tree Rewriter：重写语法树，使用的是静态规则，不会去使用实际数据

5. Optimizer：真正访问数据，计算出最优的查询计划

### 启发式
关系代数的等价性：对于同样的数据可以获得同样结果的两个代数表达式就可以认为是等价
查询重写：将关系代数表达式转化成等价的关系代数表达式的过程
通用规则
- 尽早处理filter的操作(谓词下推)
- 重新对谓词进行排序，首先处理最具选择性的谓词
- 将一个复杂的谓词拆成多个并且下放
- 尽早进行投影操作，只留下查询需要的
- 移除无意义的谓词和条件
- 嵌套查询
  - 把嵌套的子查询合并到主要的查询
  - 对嵌套的查询进行分解，将结果存储到临时表中代入到主查询

### 基于代价

使用内部的成本模型来评估一个特定查询计划的执行成本。其主要分为三个模块：
- 评估代价
- 维护统计信息
- 搜索最优计划

#### 代价
- 物理：I/O、cache miss、RAM等，极度依赖硬件，一般使用在数据库一体机
- 逻辑：每个算子开销，独立于算法
- 算法：时间复杂度、空间复杂度

#### 统计信息
假设数据是均匀分布、谓词独立、两个表join一张表中每一个tuple在另一个表中都有另一个tuple与之对应，那么可以轻松算出谓词所筛选数个数。但实际的数据肯定为更加复杂，所以需要一些更细致的统计数据方式。

- 等宽直方图，将数据取值分为N个区间，记录每个区间相关数据并维护。但对于数据倾斜差异依旧很大
- 等深直方图：将M个数据分为一个桶，按桶维护。一定程度缓解数据倾斜
- Sketches：生成对应数据的概率分布，精确度更高
- Sampling：可以采样一个子集，然后通过部分估计总体

#### 最优计划
- 单表查询，多见于OLTP事务中，只需要使用简单的规则并选择最好的访问方法即可
- 多表查询，多见于OLAP事务，需要计划列举，往往使用动态规划
  - 列举join顺序
  - 列举join算法
  - 列举访问方法

##### 优化
左深树：将多表连接转换为左深树，可以达到流水线的效果  
基因遗传算法：首先随机选出几个优种的组合，这种组合在顺序，操作算法，访问表的方面上面都是随机的，然后排除掉最差的，选择最优。然后，将其特征与其他的个体融合形成新个体。在经过多代筛选之后，选择出最优的


