# 事务
一个事务是一段连续的执行操作，事务在DBMS中的执行必须是原子的

## 并发控制理论

- 原子性：事务中的所有操作都会发生或不发生，一般通过日志实现
- 一致性：不能破坏数据库的完整性约束和业务逻辑的一致性
- 隔离性：一个事务的执行不影响其他事务的执行
- 持久性：如果事务提交，涉及的数据能够被持久化

### 串行化

- 串行计划：不同事务连续执行的计划
- 等效计划：对于任何数据库状态，如果执行第一个调度的效果与执行第二个调度的效果相同，则这两个调度是等效的
- 可串行化：通过挪动读写顺序，可以变成形式上与串行计划也相等的计划
- 冲突可串行化：交换2个没有冲突（读写、写读、写写）操作，最终可以变成可串行化调度。
  - 基于依赖图判断可串行，如果一对冲突操作中$T_i$ 事务里的操作先于$T_j$ 事务里的操作，那么就在依赖图中加一条从$T_i$ 指向$T_j$ 有向边。如果图中出现了环，那么对应的调度就不是可串行化的。但有一些特例，使用依赖图判断只会得出不可串行化，但实际上可以达到和串行化调度一样的效果
- 观察可串行性：通过观察来确定某个执行调度是可串行还是不可串行，但目前还没有DBMS能实现它

### 锁
在DBMS中，所有事务的锁由一个总的锁管理器来管理。事务请求一个锁，锁管理器给与这个锁或堵塞事务，最后由事务释放这个锁。  

#### 两阶段锁
用于确定事务是否可以动态访问数据库中的对象，该协议不需要知道事务的执行操作，也能够实现事务的可串行化
- 增长阶段：事务从锁管理器那里请求获取锁，并且一直获取而不释放
- 释放阶段：事务向锁管理器释放锁，并且一直释放而不获取

但是如果有事务回滚，那么可能出现脏读的情况，因此提出强二阶段锁，将事务释放锁的阶段全部集中到commit之后  
如果事务$T_1$获取A锁再获取B锁，$T_2$获取B锁再获取A锁，那么就有可能死锁，因此需要死锁检测或死锁避免  
- 检测死锁：定期检查等待图，看是否有闭环出现。如果检查到死锁，DBMS则会挑选一个事务进行重启或者撤销，以打破死锁循环
- 死锁预防：死锁发生之前阻止事务造成死锁。根据时间戳为事务分配优先级，DBMS会撤销其中一个事务

#### 分层锁
如果将行锁作为锁的粒度的话，那么遍历一个表就需要加N个锁并解N个锁，为了减少开销，DBMS使用层次结构，该层次结构允许事务在系统中采用更粗粒度的锁。  
但是如果一个事务只想更改部分数据，则不会对整个表上锁，此时另一个事务想要遍历整个表，需要锁整个表，那么它需要知道当前表锁的信息。为了解决这个问题，提出了意向锁，意向锁允许锁定更高级别的节点，而无需检查所有后代节点。
![intention](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee320848de434f91ad750c720bf98b77~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

#### 防止幻读
- 加表锁
- 给谓词加锁：select加共享锁，insert、delete、update加独占锁
- 给索引加锁
- 间隙锁：给记录和记录之间的间隙加锁

### 时间戳排序
事务管理器需要对每个事务T进行初始化时分配一个时间戳。该时间戳需要保持单调递增的性质，**如果$T_2$ 比$T_1$ 来的时间晚，那么数据库的状态应该等同于为$T_1$ 发生后$T_2$ 发生**。时间戳可使用系统时钟、逻辑时钟、前两者杂合

#### 基本时间戳
事务时间戳记为TS，对一个对象X上一次读和写的时间戳R-TS(X)和W-TS(X)。读写不需要加锁，但需要记录R-TS(X)或W-TS(X)。读写都遵循一个基本原则：**不要试图访问"未来"的对象**  
- 读
  - 如果TS < W-TS(X)，那么事务自杀。
  - 其他情况，读X，更新R-TS(X)为max( TS, R-TS(X) )，复制一份X用于可重复读
- 写
  - 如果TS < W-TS(X)或 TS < R-TS(X)，事务自杀
  - 其他情况，写X，更新W-TS(X)为TS，复制一份X用于可重复读

缺点：
- 对长事务不友好容易造成饥饿
- 出现事务回滚，那么可能有脏读现象且不可恢复
- 复制操作代价大

#### 基本时间戳优化
- 写优化（托马斯规则）
  - 如果TS < R-TS(X)，事务自杀
  - 如果TS < W-TS(X)，事务忽略写继续执行
  - 其他情况，写X，更新W-TS(X)为TS，复制一份X用于可重复读

- 乐观并发控制(OCC)
  - 记录W-TS，校验时赋予时间戳
  - 读阶段：读写操作记录在本地，对数据库只读不改
  - 校验阶段：当commit时，校验是否有冲突
  - 写阶段：
    - 无冲突，写数据库
    - 有冲突，选择一个事务自杀

### 隔离级别
![level](https://pic3.zhimg.com/80/v2-ee0c9a43b7e72c79660da48894b78a0e_720w.webp)

串行化：读写锁、索引锁、强二阶段锁
可重复读：不需要索引锁
读已提交：不需要索引锁，读锁可立即释放
读未提交：不需要索引锁、读锁


### 多版本并发控制
通过保存数据在多个时间点的快照来实现并发控制，本身并不能实现串行化，所以一般与两阶段锁或时间戳排序一起使用实现串行化。版本存储一般采用链表，链表可以存储对象或修改的部分。如果一个版本涉及的事务已经提交或回滚，那么就删除该版本。  

#### 索引管理
通常索引不存储关于元组及其键的版本信息，但是每个索引必须支持重复键，因为在不同的快照中，相同的索引可以指向不同的逻辑元组。这需要更多的逻辑来判断是否满足unique并且需要一些特殊方法来处理特殊情况
- 主键索引：主键的索引直接指向版本链表的头节点。如果一个事务更新了一个元组的主键，则我们把它当成先删除再添加
- 二级索引：
  - 逻辑指针，即使用元组不会改变的标识符，利用中间层来将进行转换以找到相应的版本链
  - 物理指针，即存储指向版本链表的头部的指针，更新数据则需要更改全部索引